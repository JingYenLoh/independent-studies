#+TITLE: Chapter 2
#+SUBTITLE: Hello, Modern JS!
#+AUTHOR: Jing Yen Loh
#+EMAIL: lohjingyen.16@ichat.sp.edu.sg
#+DATE: June 2018

#+BEGIN_QUOTE
(() => alert('ES2018+'))();
#+END_QUOTE

* Learning Objectives
** [ ] Provide high level overview to modern JS syntax
** [ ] Provide high level overview to tooling used in JS development

* Introduction
One major obstacle faced by Singapore Polytechnic's Diploma in Information
Technology students when attempting to learn React, as I've observed, is not due
to the complexity of the React library itself, which indeed is conceptually
lightweight compared to some JavaScript UI libraries out there, but rather
getting overwhelmed with new syntax and unfamiliar concepts. Indeed, oftentimes
documentation often assumes some familiarity with frontend JS development, as
React was not the first tool people reached for when building UIs. It is even
possible that the reader has been overwhelmed by my initial chapter. At the time
of writing, JavaScript is only briefly touched in the school's syllabus and is
woefully inadequate to cope with the massive changes JS has seen over recent
years. This chapter attempts to fill those gaps enough that the reader may at
least read the React documentation without feeling like diving into a rabbit
hole.

/Author's note: I make effort to explain things to the best of my ability, but IMHO nothing quite beats diving into documentation and writing some code yourself. To that, I include necessary links in this Chapter, and I encourage them to be visited to clarify any doubts and solidify understanding./

* ES6 and Beyond
** Beginner Gotchas
Before even diving into modern JS, I feel the need to cover certain concepts and
gotchas for beginners.
*** ES...? Isn't this JavaScript?
The short answer is JavaScript usually refers to ECMAScript (ES for short), and
JS is simply the popular name to refer to ES. So that's something to bear in
mind if you chance upon the term while reading some documentation.

The long answer is ECMAScript is the Standard for the scripting language. ECMA
stands for European Computer Manufacturer's Association, and ECMAScript is a
standard they specified for a programming language. JavaScript is an
implementation of the ECMAScript standard. The "Java" part actually came from
marketing decision, and not really due to JS being a "script" version of the
Java programming language.

This is mostly trivia/history, but I've included it to avoid potential
confusion.
*** Semicolons
In JavaScript, semicolons are optional. Unlike Java or C#, where statements are
delimited by a semicolon, the JS interpreter can guess where to delimit a
statement. In fact, it is possible to write JS completely without semicolons,
similar to programming languages such as Python. In practise, however,
semicolons are still used, and even enforced for consistency.

/Author's note: For a while I enjoyed writing JS without semicolons, but eventually succumbed to semicolons, which also allows for modern features while remaining error free. Perhaps more on that another time./
*** Null and Undefined
In most programming languages, a ~null~ could refer to a value that does not
exist or an uninitialized variable. In JS, it's slightly different.

~undefined~ is a property without a definition. It typically means a variable
that has been declared but not defined, or a non-existent property in an object.
#+BEGIN_SRC js
let x; // x is declared but not defined with a value

console.log(x); // undefined

x = {}; // We'll now assign an empty Object to x

// x doesn't have a property called nonExistentProperty
console.log(x.nonExistentProperty); // undefined
#+END_SRC

~null~, however, means /nothing/. Unlike ~undefined~, which undefined variables
default to, ~null~ has to be assigned.
#+BEGIN_SRC js
let x; // x is declared but not defined with a value

console.log(x); // undefined

x = null;

console.log(x); // null
#+END_SRC

Why both ~null~ and ~undefined~? AFAIK, this was a flaw in the design of the
language, which is tricky to fix now.
** const and let
Traditionally, the ~var~ keyword was used for variable declarations.
#+BEGIN_SRC js
var pi = 3.14;
#+END_SRC

~const~ prevents the value of the constant from being changed through /re-assignment/.
#+BEGIN_SRC js
const answerToUniverse = 42;

try {
  answerToUniverse = 99;
  // expected output: TypeError: invalid assignment to const `number'
  // Note - error messages will vary depending on browser
} catch (e) {
  console.err(e);
}

console.log(answerToUniverse);
#+END_SRC

However, ~const~ doesn't magically make the value immutable. You simply can't
change the reference.
#+BEGIN_SRC js
const arr = [1, 2, 3, 4];

arr.push(5); // Valid code

console.log(arr); // [1, 2, 3, 4, 5];

// The ... operator clones and spreads the properties in arr.
const copy = [...arr, 6]; // [1, 2, 3, 4, 5, 6]

arr = copy; // TypeError: Assignment to constant variable
#+END_SRC

~let~ works similarly to ~var~, allowing you to reassign references.
#+BEGIN_SRC js
let x = 1;
console.log(x);

x = 'chicken';
console.log(x);
#+END_SRC

So if ~let~ works similarly, what's the purpose of it? Why not just use ~const~
with ~var~?

This is a bit of gotcha for JS beginners: variables in JS are actually /function
scoped/, meaning a ~var~ declaration allows for the variable to be accessible
within a function itself. That may have sounded confusing, so here's an example:

#+BEGIN_SRC js
function aThousand() {
  for (var i = 0; i < 1000; i++) {
    // Do nothing, just using a for loop to illustrate
  }
  console.log(i);
}

aThousand();
#+END_SRC

That actually outputs ~1000~, which was possible because the /scope/ of ~i~ was
the /function/ (~aThousand~) itself. Contrast that to the following example in
C#:
#+BEGIN_SRC csharp
int aThousand()
{
    for (var i = 0; i < 1000; i++)
    {
        // Do nothing
    }
    Console.WriteLine(i); // The name 'i' does not exist in the current context
}
#+END_SRC

That happens because ~i~ was /block scoped/, meaning that it existed within the
curly braces (~{}~). Blocks are a much more common way to scope variables (C,
C++, Java, C#, etc all use block scoping). Function scoping introduces a lot of
gotchas for people unfamiliar with it in JS, and thus ~const~ and ~let~
introduces block scoping to JS (besides ~const~'s immutable references).

/Author's note: I use ~const~ almost exclusively, unless I know I'll explictly need a mutable reference, in which case I use ~let~. I find it helps me reason about my code better./
** Default Parameters
Conceptually simple, but before that let's cover a JS beginner gotcha. Given the
following function:

#+BEGIN_SRC js
function greet(name) {
  console.log('Hello, ' + name + '!');
}

greet('Francis');
greet();
#+END_SRC

The first call would log ~Hello, Francis!~ to the console. What happens when we
call ~greet();~ though? Surprise: the code runs! In JS, it is possible to omit
arguments to functions if you do not intend to use them, and they will default
to ~undefined~, as evidenced by the second ~greet~ call.

We can override this default by providing a default parameter, which will be
used instead when the argument is ~undefined~:
#+BEGIN_SRC js
// Default parameter of 'nameless'
function greet(name = 'nameless') {
  console.log('Hello, ' + name + '!');
}

greet();
#+END_SRC

The above would output ~Hello, nameless!~. Default parameters are great for
leaving sane defaults in arguments that you know will be commonly passed.
** Classes
** Destructuring
One of my favorite language features. Before we proceed, let's clear up some
terminology. Here's a JavaScript Object.

#+BEGIN_SRC js
const person = {
  name: 'Francis',
  gender: null
};
#+END_SRC

~person~ is an identifier for the Object, which consists of 2 /keys/, each with
a corresponding /value/.

| key    | value   |
|--------+---------|
| name   | Francis |
| gender | null    |

It's common to be writing code like the following:
#+BEGIN_SRC js
const name = person.name;
#+END_SRC


Destructuring allows you to extract the /key/ and assign it to a variable
simultaneously:
#+BEGIN_SRC js
const { name } = person;
#+END_SRC

Multiple keys are fine too:
#+BEGIN_SRC js
const { name, gender } = person;
#+END_SRC

Destructuring works on Arrays as well:
#+BEGIN_SRC js
const [first, second, ...rest] = [1, 2, 3, 4, 5];

console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]
#+END_SRC

As well as Modules, which we'll cover later. In fact, you'll frequently see the
following examples in React:
#+BEGIN_SRC js
// You're extracting Component directly from the 'react' import
import React, { Component } from 'react';

class ButtonComponent extends Component {
  // ...
}
#+END_SRC

#+BEGIN_SRC js
// Without the destructuring, it would be like the following:
import React from 'react';

class ButtonComponent extends React.Component {
  // ...
}
#+END_SRC

I particularly like destructuring function arguments, especially with React
components:
#+BEGIN_SRC js
let TodoItem = ({ taskName, isDone }) => (
  <li>
    <p>{taskName}</p>
    <input type="checkbox" value={isDone} />
  </li>
);

// VERSUS
TodoItem = (props) => (
  <li>
    <p>{props.taskName}</p>
    <input type="checkbox" value={props.isDone} />
  </li>
);
#+END_SRC
** TODO Spread
** Modules (not really ES6)
JS was initially designed for simple interactions on the client side, and thus
the original designers did not see the need for a module system. As the
complexity of web applications grew, however, splitting up pieces of code became
essential. Specifications like CommonJs and Asynchronous Module Definition (AMD)
rose to deal with the problem.

Eventually, the ECMA committee decided to tackle this issue as well, and the
result was ES2015 Modules.
#+BEGIN_SRC js
// -- math.js
export const PI = 3.1415;

export function areaOfCircle(r) {
  return PI * r * r;
}

const Math = {
  PI,
  areaOfCircle,
};

export default Math;

// -- index.js
import Math from './math.js'; // The default export is brought in

const radius = 5;

console.log(Math.areaOfCircle(5)); // 78.5375
#+END_SRC

An ~export~ keyword allows something to be exported, and an ~import~ brings it
into the current namespace.

Imports can be destructured, and you'll commonly see it in React:
#+BEGIN_SRC js
// continued example
import { areaOfCircle } from './math.js';

// React example
import React, { Component } from 'react';
#+END_SRC

You can give your imports a custom namespace using an ~as~:
#+BEGIN_SRC js
// continued example
import * as Api from './math.js';

console.log(Api.PI);

// React/Redux example
import { TodosReducer as Todo } from './TodosReducer.js';
#+END_SRC

There are several nuances with modules, and frankly the [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import][MDN documentation]] covers
it much better than my brief summary here. I encourage the reader to visit the
documentation instead.
** TODO Promises

* Common tooling
** Babel
JavaScript is continually evolving as a language, and new features are
constantly being added. /Proposals/ are written for new features, where it goes
through several stages of a proposal process, and gets finalized into the
language specifications if it gets accepted.

Babel is a JavaScript compiler (some call it transpiler) which supports the
latest language features. It takes in next generation JavaScript (with features
that're currently in proposals and not part of the spec yet) and churns out
JavaScript that's supported in browsers. Babel does this through plugins that
transform the syntax.

You're most likely already using Babel if you're using JSX. Babel takes
something with JSX...
#+BEGIN_SRC js
const HelloComponent = <Text>Hello!</Text>;
#+END_SRC

and transforms it into something like this:
#+BEGIN_SRC js
const HelloComponent = React.createElement(
  Text,
  null,
  "Hello!",
);
#+END_SRC

Surprise! Turns out JSX isn't actually part of JavaScript, but rather a Babel
enabled feature for you to write XML looking UIs which gets transpiled into
JavaScript functions.

Besides JSX, ~create-react(-native)-app~ generated projects usually incorporate
some experimental languages features (a.k.a. still in proposal). At the time of
writing, this includes features like [[https://github.com/tc39/proposal-static-class-features/][static class features]] and [[https://github.com/tc39/proposal-dynamic-import][dynamic import]].
** TODO Webpack
