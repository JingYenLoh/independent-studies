#+TITLE: Chapter 2
#+SUBTITLE: Hello, Modern JS!
#+AUTHOR: Jing Yen Loh
#+EMAIL: lohjingyen.16@ichat.sp.edu.sg
#+DATE: June 2018

#+BEGIN_QUOTE
(() => alert('ES2018+'))();
#+END_QUOTE

* Learning Objectives
** [ ] Provide high level overview to modern JS syntax
** [ ] Provide high level overview to tooling used in JS development

* Introduction
One major obstacle faced by Singapore Polytechnic's Diploma in Information
Technology students when attempting to learn React, as I've observed, is not due
to the complexity of the React library itself, which indeed is conceptually
lightweight compared to some JavaScript UI libraries out there, but rather
getting overwhelmed with new syntax and unfamiliar concepts. Indeed, oftentimes
documentation often assumes some familiarity with frontend JS development, as
React was not the first tool people reached for when building UIs. It is even
possible that the reader has been overwhelmed by my initial chapter. At the time
of writing, JavaScript is only briefly touched in the school's syllabus and is
woefully inadequate to cope with the massive changes JS has seen over recent
years. This chapter attempts to fill those gaps enough that the reader may at
least read the React documentation without feeling like diving into a rabbit
hole.

/Author's note: I make effort to explain things to the best of my ability, but IMHO nothing quite beats diving into documentation and writing some code yourself. To that, I include necessary links in this Chapter, and I encourage them to be visited to clarify any doubts and solidify understanding./

* ES6 and Beyond
** Beginner Gotchas
Before even diving into modern JS, I feel the need to cover certain concepts and
gotchas for beginners.
*** ES...? Isn't this JavaScript?
The short answer is JavaScript usually refers to ECMAScript (ES for short), and
JS is simply the popular name to refer to ES. So that's something to bear in
mind if you chance upon the term while reading some documentation.

The long answer is ECMAScript is the Standard for the scripting language. ECMA
stands for European Computer Manufacturer's Association, and ECMAScript is a
standard they specified for a programming language. JavaScript is an
implementation of the ECMAScript standard. The "Java" part actually came from
marketing decision, and not really due to JS being a "script" version of the
Java programming language.

This is mostly trivia/history, but I've included it to avoid potential
confusion.
*** Semicolons
In JavaScript, semicolons are optional. Unlike Java or C#, where statements are
delimited by a semicolon, the JS interpreter can guess where to delimit a
statement. In fact, it is possible to write JS completely without semicolons,
similar to programming languages such as Python. In practise, however,
semicolons are still used, and even enforced for consistency.

/Author's note: For a while I enjoyed writing JS without semicolons, but eventually succumbed to semicolons, which also allows for modern features while remaining error free. Perhaps more on that another time./
*** Null and Undefined
** const and let
Traditionally, the ~var~ keyword was used for variable declarations.
#+BEGIN_SRC js
var pi = 3.14;
#+END_SRC

~const~ prevents the value of the constant from being changed through /re-assignment/.
#+BEGIN_SRC js
const answerToUniverse = 42;

try {
  answerToUniverse = 99;
  // expected output: TypeError: invalid assignment to const `number'
  // Note - error messages will vary depending on browser
} catch (e) {
  console.err(e);
}

console.log(answerToUniverse);
#+END_SRC

However, ~const~ doesn't magically make the value immutable. You simply can't
change the reference.
#+BEGIN_SRC js
const arr = [1, 2, 3, 4];

arr.push(5); // Valid code

console.log(arr); // [1, 2, 3, 4, 5];

// The ... operator clones and spreads the properties in arr.
const copy = [...arr, 6]; // [1, 2, 3, 4, 5, 6]

arr = copy; // TypeError: Assignment to constant variable
#+END_SRC

~let~ works similarly to ~var~, allowing you to reassign references.
#+BEGIN_SRC js
let x = 1;
console.log(x);

x = 'chicken';
console.log(x);
#+END_SRC

So if ~let~ works similarly, what's the purpose of it? Why not just use ~const~
with ~var~?

This is a bit of gotcha for JS beginners: variables in JS are actually /function
scoped/, meaning a ~var~ declaration allows for the variable to be accessible
within a function itself. That may have sounded confusing, so here's an example:

#+BEGIN_SRC js
function aThousand() {
  for (var i = 0; i < 1000; i++) {
    // Do nothing, just using a for loop to illustrate
  }
  console.log(i);
}

aThousand();
#+END_SRC

That actually outputs ~1000~, which was possible because the /scope/ of ~i~ was
the /function/ (~aThousand~) itself. Contrast that to the following example in
C:
#+BEGIN_SRC csharp
int aThousand()
{
    for (var i = 0; i < 1000; i++)
    {
        // Do nothing
    }
    Console.WriteLine(i); // The name 'i' does not exist in the current context
}
#+END_SRC

That happens because ~i~ was /block scoped/, meaning that it existed within the
curly braces (~{}~). Blocks are a much more common way to scope variables (C,
C++, Java, C#, etc all use block scoping). Function scoping introduces a lot of
gotchas for people unfamiliar with it in JS, and thus ~const~ and ~let~
introduces block scoping to JS (besides ~const~'s immutable references).

/Author's note: I use ~const~ almost exclusively, unless I know I'll explictly need a mutable reference, in which case I use ~let~. I find it helps me reason about my code better./
** Default Parameters
Conceptually simple, but before that let's cover a JS beginner gotcha. Given the
following function:

#+BEGIN_SRC js
function greet(name) {
  console.log('Hello, ' + name + '!');
}

greet('Francis');
greet();
#+END_SRC

The first call would log ~Hello, Francis!~ to the console. What happens when we
call ~greet();~ though? Surprise: the code runs! In JS, it is possible to omit
arguments to functions if you do not intend to use them, and they will default
to ~undefined~, as evidenced by the second ~greet~ call.

We can override this default by providing a default parameter, which will be
used instead when the argument is ~undefined~:
#+BEGIN_SRC js
function greet(name = 'nameless') {
  console.log('Hello, ' + name + '!');
}

greet();
#+END_SRC

The above would output ~Hello, nameless!~. Default parameters are great for
leaving sane defaults in arguments that you know will be commonly passed.
** Classes
** Destructuring
One of my favorite language features. Before we proceed, let's clear up some
terminology. Here's a JavaScript Object.

#+BEGIN_SRC js
const person = {
  name: 'Francis',
  gender: null
}
#+END_SRC

~francis~ is an identifier for the Object, which consists of 2 /keys/, each with
a corresponding /value/.

| key    | value   |
|--------+---------|
| name   | Francis |
| gender | null    |

It's common to be writing code like the following:
#+BEGIN_SRC js
const name = person.name;
#+END_SRC


Destructuring allows you to extract the /key/ and assign it to a variable
simultaneously:
#+BEGIN_SRC js
const { name } = person;
#+END_SRC

Multiple keys are fine too:
#+BEGIN_SRC js
const { name, gender } = person;
#+END_SRC

Destructuring works on Arrays as well:
#+BEGIN_SRC js
const [first, second, ...rest] = [1, 2, 3, 4, 5];

console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]
#+END_SRC

As well as Modules, which we'll cover later. In fact, you'll frequently see the
following examples in React:
#+BEGIN_SRC js
// You're extracting Component directly from the 'react' import
import React, { Component } from 'react';

class ButtonComponent extends Component {
  // ...
}
#+END_SRC

#+BEGIN_SRC js
// Without the destructuring, it would be like the following:
import React from 'react';

class ButtonComponent extends React.Component {
  // ...
}
#+END_SRC

I particularly like destructuring function arguments, especially with React
components:
#+BEGIN_SRC js
let TodoItem = ({ taskName, isDone }) => (
  <li>
    <p>{taskName}</p>
    <input type="checkbox" value={isDone} />
  </li>
);

// VERSUS
TodoItem = (props) => (
  <li>
    <p>{props.taskName}</p>
    <input type="checkbox" value={props.isDone} />
  </li>
);
#+END_SRC
** Modules (not really ES6)
** Promises
** Thoughts
That was indeed lengthy, but with covering all that, I hope that the reader will
be able to dive into any React library with speed, and immediately be able to
read the code.
